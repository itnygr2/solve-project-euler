---
# Thoughts on problem i'm still working on 
---
- ### p169
- some sorta binary combinatorics problem, each '1' in the number's binary representation has a 'collapsing range'
- 1000 -> 200 -> 120 -> 112 (in bad binary notation)
- 8 -> 4+4 -> 4+2+2 -> 4+2+1+1
- but if a '1' collapses into another, smaller '1', we can no longer multiply the number of ways. instead we multiply by the number of ways minus one.
- example:
- 10 is 1010 in binary, the second 1 can 'collapse' once, becoming a 2.
- so we have 
---
- ### p754
- instead of thinking of multiplying all the numbers together naively, think of how many times a given number appears in the G function.
- this gives an 'inverse euler totient function', so to speak. the function takes in a number n and another number x, and outputs how many times x gets multiplied in G for G(n).
- but observe that the 'inverse totient function' can be done by inclusion-exclusion.
- for highly composite numbers (2*3*5*7*..), this only goes up to like, 20 numbers before the product reaches 10**25 so it's tractable.
- and we get powermod built into python's pow function. 
- i think this is solved then. looks daunting though XD
---
- ### p626
- burnside's lemma with a TON of matrix tricks
- definitely the hardest i've seen so far
---
- ### p199
- soddy circles...
